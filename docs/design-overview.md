# Ralis Support Hub — Design Overview
**Tech Support Platform | Architecture & Delivery Plan**  
**Status:** Draft (post‑kickoff consolidation)

---

## 1. Purpose
Ralis Support Hub is an internally developed support platform intended to replace today’s fragmented tooling (e.g., Zendesk, ServiceNow, ad‑hoc shared inboxes) with a single, centralized system that Ralis owns, can audit, and can extend.

The system’s north star is: **one place to intake, route, work, and report on support requests across multiple company entities**.

---

## 2. Context
### 2.1 Supported entities
The platform must support multiple companies/entities (initial expectation expanded during kickoff). The entities mentioned so far include:
- TLE
- CSBK
- CashCall
- Servicing Solution
- LCE
- LNRES
- Additional marketing/other entities (TBD)

**Requirement:** entities must be **data-driven** and **admin-manageable** (no code changes required to add/remove).

### 2.2 Current pain points (why we’re doing this)
- Requests arrive through disconnected channels (email, Teams pings, disparate systems) with no unified view.
- Ticket submissions are often low-quality (minimal context, screenshot-only, missing system/error details).
- Limited shared visibility between Tech Support (ops) and App Support (dev).
- Audit/SOX reporting is manual and time-consuming (e.g., terminations/access requests by date range).

---

## 3. Goals, Non‑Goals, and Success Criteria
### 3.1 Goals (v1–v2 horizon)
1. **Centralized ticket lifecycle**: create, triage, assign, respond, close.
2. **Multi-entity support** with clean data separation and per-entity configuration.
3. **Structured intake first** (web form) to improve data completeness.
4. **Email integration** for shared mailboxes (create/append tickets).
5. **Auditability + reporting** (SOX-oriented) as a first-class requirement.
6. **Extensibility** for future KB/self-service and API-based intake.

### 3.2 Non‑Goals (explicitly out of initial scope)
- Full ITSM replacement (CMDB, change management, etc.).
- Advanced KB/RAG implementation in v1 (planned later).
- Business-hours SLA clocks / pause/resume rules in v1 (data model anticipates future).

### 3.3 Success criteria (measurable)
- ≥80–90% of new tickets submitted via the structured web form (after rollout).
- Email-created tickets reliably thread and append (header-based matching works).
- SOX-style reports (terminations, access requests) can be generated by date range without manual spreadsheet triage.
- Cross-team visibility: shared queues, status tracking, and searchable history.

---

## 4. Users, Roles, and Permissions
### 4.1 Roles (initial)
- **Super Admin**: global configuration (companies, roles, routing rules).
- **Admin**: per-company configuration, queue/routing management.
- **Agent**: works tickets; internal notes; replies; status/assignment changes.

### 4.2 Authentication & Authorization
- **Authentication:** Azure AD (M365 identities) via Microsoft.Identity.Web.
- **Authorization:** role/group-based, enforced in the API/service layer (not just UI).
- **Tenant isolation:** per-company access must be enforced in queries and services.

---

## 5. Functional Requirements
### 5.1 Ticket intake
**Primary:** Structured web form
- Required: Company/Entity, System/Application, Issue Type, Subject, Description (with minimum content), Attachments.
- Goal: reduce “screenshot-only” and unstructured submissions.

**Secondary:** Inbound email (shared mailboxes)
- Creates new tickets when no thread match exists.
- Appends to existing tickets via thread matching.

**Future:** API intake
- Programmatic ticket creation endpoint for integrations/webhooks.

### 5.2 Ticket lifecycle (core)
- Create, update, assign, change status/priority, close.
- Internal notes (agent-only).
- Attachments stored and associated with messages/tickets.
- Canned responses (global or company-scoped).
- Tags for categorization and reporting.

### 5.3 Routing & queues
- Admin-configurable **routing rules** (ordered evaluation).
- Default fallback queue when no rule matches.
- Queues are configurable; initial examples include:
  - Tech Support
  - App Support
  - General
  - New Hire / Termination
- Future expansion into additional functional queues as needed.

---

## 6. Non‑Functional Requirements
### 6.1 Audit & compliance
- Capture ticket history and key state changes.
- Support SOX-style audit reports by tag/type and date range.
- Favor retention and traceability: soft-delete + audit log events.

### 6.2 SLA monitoring
- Track time-to-first-response and time-to-resolution.
- Background job checks against per-company/per-priority SLA policy.
- v1 uses wall-clock elapsed time; future may add business-hours logic.

### 6.3 Security
- Azure AD-only (no local accounts).
- Server-side secret management (env vars / Key Vault).
- Company isolation enforced at the service layer.
- File upload validation; consider antivirus scanning in later phase.
- HTTPS everywhere.

### 6.4 Operability
- Background jobs and polling must be observable (logs/metrics).
- Database and attachment storage must be backed up.
- System should be deployable via CI/CD with environment-based configuration.

---

## 7. Architecture
### 7.1 High-level architecture
**UI:** Blazor Web App (.NET 10) with Server interactivity + MudBlazor  
**API:** ASP.NET Core Web API (.NET 10)  
**DB:** SQL Server (on‑prem)  
**Auth:** Azure AD  
**Email:** Microsoft Graph API  
**Background jobs:** Hangfire  
**Real-time:** SignalR (as needed; aligned with Blazor Server interactivity)

### 7.2 Storage architecture
- **Primary DB:** ticket metadata, messages, routing, audit logs, SLA records.
- **Attachment storage:** on‑prem network share for v1 (cost-driven), behind `IFileStorageService` abstraction to enable future move to Blob storage if needed.

### 7.3 Runtime model (v1)
- Web + API in one solution footprint initially.
- Shared service interfaces used by both Blazor UI and API controllers.
- Contracts structured so API hosting can be separated later without rewrites.

---

## 8. Data Model (v1 conceptual)
### 8.1 Core entities
**Organization & access**
- `Company` (entity name, mailbox config, SLA config, branding)
- `Division` (optional queue grouping)
- Azure AD user mapping with role + assigned companies

**Ticketing**
- `Ticket` (CompanyId, status, priority, assigned agent, SLA timestamps, source, tags, routing target, AI metadata)
- `TicketMessage` (inbound/outbound, body, sender, timestamps)
- `TicketAttachment` (file path, original name, MIME type)
- `InternalNote` (agent-only)
- `TicketTag` (flexible reporting taxonomy)

**Routing**
- `RoutingRule` (ordered, enable/disable, match criteria)
- `CannedResponse`

**Compliance & SLA**
- `AuditLog` (user/action/entity/timestamp + details)
- `SlaPolicy`
- `SlaBreachRecord`
- `CustomerSatisfactionRating` (post-close)

**Future knowledge**
- `KnowledgeBaseArticle` (company-scoped; future RAG integration)

### 8.2 Key data decisions
- **Single database** with `CompanyId` FK isolation (not separate DBs).
- **Soft-delete** with retention (`IsDeleted`, `DeletedAt`).
- **UTC timestamps** stored; convert for display.
- **Tags over rigid enums** for audit/reporting agility.

---

## 9. Email Integration (Graph) — Threading Contract
### 9.1 Thread identifier
Canonical header: `X-SupportHub-TicketId`  
(Subject token matching is a fallback only.)

### 9.2 Inbound flow
- Hangfire polls each company’s shared mailbox on an interval (e.g., 1–2 minutes).
- If no existing ticket match → create `Ticket` + inbound `TicketMessage`.
- If match exists → append as inbound `TicketMessage`.
- If routing is ambiguous/unstructured → use AI classification (see §10).

### 9.3 Outbound flow
- Agents reply using the company shared mailbox via Graph API.
- Persist outbound messages as `TicketMessage` (Outbound).
- Always inject `X-SupportHub-TicketId` for reliable threading.

---

## 10. Routing Strategy (Rules First, AI as Assist)
### 10.1 Rules engine (admin-configurable)
Rules evaluate (ordered):
- Sender domain
- Keyword match (subject/body)
- Web form fields (company/system/issue type)
- Tags / issue-type mappings (e.g., termination/new-hire)

Unmatched tickets go to a default queue.

### 10.2 AI-assisted classification (email-first)
For email tickets that lack structured fields (and for image-only submissions), an image-capable LLM may suggest:
- routing queue
- tags

**Implementation note:** AI outcomes must be recorded (for audit + tuning).

---

## 11. Delivery Plan (Phased)
### Phase 1 — Foundation
- Solution structure + shared libraries + EF Core migrations
- Azure AD auth + role authorization
- Company/entity admin management (data-driven)
- CI/CD pipeline (Azure DevOps)
- ADO project board setup

### Phase 2 — Core ticketing (web-first)
- Web form intake + validations
- Ticket lifecycle (assign/status/priority/close)
- Attachments + on‑prem storage
- Lists/filters (company/status/agent/priority/queue/tag)
- Internal notes, canned responses, tags

### Phase 3 — Email integration
- Graph API connectivity + required admin consent
- Inbound polling, ticket creation/appending
- Outbound replies via shared mailbox
- Threading via `X-SupportHub-TicketId` header
- AI classification for unstructured email tickets

### Phase 4 — Routing UI & management
- Admin UI for rules CRUD + ordering + enable/disable
- Queue management UI
- Rules pipeline + fallback behavior

### Phase 5 — SLA & satisfaction
- SLA policy configuration
- SLA monitoring job + UI indicators
- Customer satisfaction capture on close

### Phase 6 — Audit reporting & knowledge base
- Audit/compliance reports (tags + date ranges)
- Dashboard metrics
- KB CRUD + search
- Future: SharePoint RAG integration

### Phase 7 — Hardening
- UX/accessibility refinements
- Audit logging validation
- Load/performance testing
- Documentation + monitoring

---

## 12. Decision Record (ADR-lite)
| Decision | Rationale |
|---|---|
| On‑prem SQL Server for primary DB | Aligns with environment constraints; supports direct reporting needs |
| On‑prem attachment storage (v1) behind `IFileStorageService` | Cloud storage cost concerns; preserve option to migrate later |
| Single DB with `CompanyId` isolation | Simplifies operations while supporting multi-entity separation |
| Web form as primary intake | Improves ticket data quality vs. email-only |
| Graph API + polling with Hangfire | Works with M365 shared mailboxes; supports incremental adoption |
| Rules engine is admin-managed | Reduce dev dependency for routing changes |
| AI assist for unstructured/email/image tickets | Addresses unavoidable unstructured inputs; reduces manual triage |

---

## 13. Risks, Dependencies, and Open Items
### 13.1 Key dependencies
- Graph API admin consent for mailbox access (e.g., Mail.ReadWrite) is a Phase 3 blocker.
- SQL Server provisioning and storage allocation for attachments.

### 13.2 Risks
- Email threading reliability if header injection is blocked; subject token fallback is less reliable.
- AI routing accuracy early on; must monitor and tune.
- SLA semantics may expand (business hours, pause clocks); ensure model supports evolution.

### 13.3 Open items
- Confirm the authoritative list of companies/entities and mailbox mappings.
- Confirm “must-have” SOX report formats and required fields/tags.
- Confirm initial issue-type taxonomy for the web form.
- Confirm ownership for routing rule administration and ongoing policy maintenance.

---

## 14. Immediate Next Steps
- Provision ADO board and CI/CD scaffolding.
- Lock initial schema + migrations for Phase 1.
- Start Company/entity admin UI and RBAC wiring.
- Begin Graph consent process in parallel with Phase 1–2 work.
